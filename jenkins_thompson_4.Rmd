---
title: "Homework 4"
author: "Emmie Jenkins and Bradley Thompson"
date: "10/25/2020"
output: pdf_document
---

```{r setup, echo=FALSE, results=TRUE}
knitr::opts_chunk$set(error=TRUE, dev="cairo_pdf")
```


a)
```{r q1a, message=FALSE}
library("tidyverse")
library("extrafont")
library("viridis")
library("MASS")

#theme_set(theme_minimal())
theme_set(theme_minimal(base_family = "Roboto Condensed"))
#theme_update(panel.grid.minor = element_blank())

ggplot(diamonds) +
  geom_histogram(aes(carat), binwidth = 1/6) +
  geom_freqpoly(aes(carat), color="red", binwidth=1/6) +
  geom_point(stat="bin", aes(carat), binwidth=1/6, color="red")
```

b)
```{r q1b}
n <- 101
df <- expand.grid(
  "x" = seq(0, 2*pi, length.out = n), 
  "y" = seq(0, 2*pi, length.out = n)
)

df <- df %>% 
  mutate("fuzz" = (sin(2*x) + sin(2*y)) / 2)

ggplot(df, aes(x, y, fill = fuzz))+
  geom_tile()+
  theme_minimal()+
  scale_fill_viridis(limits = c(-1,1), breaks = c(-1, -0.5, 0, 0.5, 1))+
  scale_x_continuous(name = "",
                     breaks = 0:4,
                     minor_breaks = NULL,
    labels = expression(0, pi/2, pi, 3*pi/2, 2*pi))+
   scale_y_continuous(name = "",
                     breaks = 0:4,
                     minor_breaks = NULL,
    labels = expression(0, pi/2, pi, 3*pi/2, 2*pi))+
  labs(fill = "f(x,y)")
  
   
  
```


c)
```{r q1c, eval=FALSE}
df <- data.frame(x = 1:5, y = 1:5)

dens_df <- data.frame(1:5, 1:5, kde2d(1:5, 1:5)) 

ggplot(df, aes(x,y))+
  stat_density2d( 
    aes(fill = stat(ndensity)),
    geom = "raster", 
    contour = FALSE
  )+
  scale_fill_viridis()+
  geom_point(color = "red", size = 3)

```


d)
```{r}
#should be easy; may need to each have individual answers and may not even need any code
```

e)
```{r pressure}

#need to figure out how to make the points jitter slightly 
set.seed(2)
logistic <- function(x) 1 / (1 + exp(-x))
n <- 50
df <- tibble(
  x = c(rnorm(n, -1),rnorm(n, 1)),
  p = logistic(0 + 2*x),
  y = rbinom(2*n, 1, p)
  )

ggplot(df, aes(x, y)) +
  geom_jitter(height=.01) + 
  stat_smooth(method = "glm", method.args=list(family = "binomial"))
```


2pre)
```{r echo=FALSE}
dot <- function(x, y){
  total <- 0
  for(i in 1:length(x)){
    total <- total + x[i] * y[i]
  }
  total
}

norm <- function(x){
  xnorm <- sqrt(dot(x,x))
  xnorm
}

normalize <- function(x){
  xnormalize <- x
  if(norm(x) != 0){
    for (i in 1:length(x)){
      xnormalize[i] <- xnormalize[i]/norm(x)
    }
  }
  xnormalize
}
```

a)
```{r q2a}
make_positive <- function(x) sign(x[1]) * x

emax <- function(A, tol = sqrt(.Machine$double.eps)) {
  y <- c(1, rep(0, ncol(A)-1))
  new_norm <- 1
  old_norm <- 0
  while(abs(new_norm - old_norm) > tol){
    old_norm <- new_norm
    y <- A %*% y
    new_norm <- norm(y)
    y <- normalize(y)
    y <- make_positive(y)
  }
  
  list("value" = t(y) %*% A %*% y, "vector" = y)
}

#testing function
(A <- matrix(c(1:4, 6:10), nrow = 3, byrow = TRUE))
eigen(A)
emax(A)
```

b)
```{r q2b}
make_first_row_positive <- function(A) apply(A, 2, make_positive)

eigen_qr <- function(A, tol = sqrt(.Machine$double.eps)){
  # initialize A_i and U_i
  A_i <- A
  U_i <- diag(ncol(A))
  
  while (TRUE) {
    # do the QR decomposition
    QR <- qr(A_i)
    Q_i <- qr.Q(QR)
    R_i <- qr.R(QR)
    
    # reorganize and update U
    U_i_1 <- U_i
    A_i <- R_i %*% Q_i
    U_i <- make_first_row_positive(U_i %*% Q_i)
  
    if (norm(U_i - U_i_1) <= tol) break
  }
  
  list("values" = diag(A_i), "vectors" = U_i)
}

#testing function
(A <- matrix(c(1:4, 6:10), nrow = 3, byrow = TRUE))
A <- crossprod(A)
eigen(A)
eigen_qr(A)
```

c)
```{r q2c}
det_qr <- function(A){
  x <- eigen_qr(A)
  y <- x$values
  z <- 1
  for(i in 1:length(y)){
    z <- z * y[i]
  }
  z
}

#testing
set.seed(2)
A <- matrix(rpois(64, lambda = 5), nrow = 8)
A <- crossprod(A)
det(A)
det_qr(A)
```




